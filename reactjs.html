---
layout: default
title: React.js
---

<h2 class="mb-3">React.js</h2>
<h3 class="mb-4">Interview Preparation Notes</h3>

<!-- =============================== -->
<!-- React Internal Working Section -->
<!-- =============================== -->

<div class="accordion mb-4" id="coreReactAccordion">

  <div class="accordion-item">
    <h2 class="accordion-header">
      <button class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#reactInternals">
        How React.js Works Internally (Core Concepts)
      </button>
    </h2>

    <div id="reactInternals"
         class="accordion-collapse collapse"
         data-bs-parent="#coreReactAccordion">

      <div class="accordion-body">

        <h5>1️⃣ Virtual DOM</h5>
        <ul>
          <li>React creates a lightweight copy of the real DOM called the <strong>Virtual DOM</strong>.</li>
          <li>Whenever state or props change, React updates the Virtual DOM first.</li>
          <li>It compares the updated Virtual DOM with the previous version.</li>
        </ul>

        <h5>2️⃣ Diffing Algorithm (Reconciliation)</h5>
        <ul>
          <li>React uses a smart diffing algorithm to compare old and new Virtual DOM trees.</li>
          <li>Instead of re-rendering the entire DOM, React finds only the changed nodes.</li>
          <li>This process is called <strong>Reconciliation</strong>.</li>
          <li>React uses keys to efficiently track list changes.</li>
        </ul>

        <h5>3️⃣ Rendering Process</h5>
        <ul>
          <li>State/Props change → Virtual DOM updates</li>
          <li>Diffing happens</li>
          <li>Only changed elements are updated in the real DOM</li>
          <li>This makes React fast and efficient.</li>
        </ul>

        <h5>4️⃣ Fiber Architecture</h5>
        <ul>
          <li>React Fiber is the internal engine of React.</li>
          <li>It allows incremental rendering.</li>
          <li>Supports features like Concurrent Mode.</li>
          <li>Improves UI responsiveness.</li>
        </ul>

        <h5>5️⃣ Why Babel is Used</h5>
        <ul>
          <li>Browsers do not understand JSX directly.</li>
          <li>Babel converts JSX into regular JavaScript.</li>
          <li>Example:</li>
        </ul>

<pre>
JSX:
&lt;h1&gt;Hello&lt;/h1&gt;

Converted by Babel:
React.createElement("h1", null, "Hello");
</pre>

        <ul>
          <li>Babel also converts modern ES6+ syntax to browser-compatible JavaScript.</li>
        </ul>

      </div>
    </div>
  </div>

</div>


<!-- =============================== -->
<!-- Existing Accordion Below -->
<!-- =============================== -->


<div class="accordion" id="mainAccordion">

  <div class="accordion-item">
    <h2 class="accordion-header">
      <button class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#reactSection">
        React.js Specific Interview Questions
      </button>
    </h2>

    <div id="reactSection"
         class="accordion-collapse collapse"
         data-bs-parent="#mainAccordion">

      <div class="accordion-body">

        <div class="accordion" id="reactSubAccordion">

          <!-- Functional vs Class -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button class="accordion-button collapsed"
                      type="button"
                      data-bs-toggle="collapse"
                      data-bs-target="#functional">
                1. Functional vs Class Components
              </button>
            </h2>

            <div id="functional"
                 class="accordion-collapse collapse"
                 data-bs-parent="#reactSubAccordion">
              <div class="accordion-body">
                <ul>
                  <li>Class components use lifecycle methods.</li>
                  <li>Functional components use Hooks.</li>
                  <li>Modern React prefers functional components.</li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Hooks -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button class="accordion-button collapsed"
                      type="button"
                      data-bs-toggle="collapse"
                      data-bs-target="#hooks">
                2. Hooks
              </button>
            </h2>

            <div id="hooks"
                 class="accordion-collapse collapse"
                 data-bs-parent="#reactSubAccordion">
              <div class="accordion-body">
                <ul>
                  <li><code>useState</code> – Manage local component state.</li>
                  <li><code>useEffect</code> – Handle side effects.</li>
                  <li><code>useMemo</code> – Memoize expensive values.</li>
                  <li><code>useCallback</code> – Memoize functions.</li>
                  <li><code>useRef</code> – Access DOM or persist values.</li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Context API -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button class="accordion-button collapsed"
                      type="button"
                      data-bs-toggle="collapse"
                      data-bs-target="#context">
                3. Context API
              </button>
            </h2>

            <div id="context"
                 class="accordion-collapse collapse"
                 data-bs-parent="#reactSubAccordion">
              <div class="accordion-body">
                <p>Context API allows sharing global data without prop drilling.</p>
                <ul>
                  <li>Create using <code>React.createContext()</code></li>
                  <li>Wrap with <code>Provider</code></li>
                  <li>Consume using <code>useContext()</code></li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Pure vs Impure Components -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button class="accordion-button collapsed"
                      type="button"
                      data-bs-toggle="collapse"
                      data-bs-target="#pure">
                4. Pure vs Impure Components
              </button>
            </h2>

            <div id="pure"
                 class="accordion-collapse collapse"
                 data-bs-parent="#reactSubAccordion">
              <div class="accordion-body">

                <h6>Pure Component</h6>
                <ul>
                  <li>Same output for same props & state.</li>
                  <li>No side effects inside render.</li>
                  <li>Predictable and easy to test.</li>
                </ul>

<pre><code>
function Greeting({ name }) {
  return &lt;h1&gt;Hello {name}&lt;/h1&gt;;
}
</code></pre>

                <hr/>

                <h6>Impure Component</h6>
                <ul>
                  <li>Output may change without prop/state change.</li>
                  <li>Uses external variables or random values.</li>
                </ul>

<pre><code>
let count = 0;

function Counter() {
  count++;
  return &lt;h1&gt;Count: {count}&lt;/h1&gt;;
}
</code></pre>

                <hr/>

                <h6>React.PureComponent vs React.memo</h6>

                <table class="table table-bordered">
                  <thead>
                    <tr>
                      <th>Feature</th>
                      <th>React.PureComponent</th>
                      <th>React.memo()</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Used With</td>
                      <td>Class Components</td>
                      <td>Functional Components</td>
                    </tr>
                    <tr>
                      <td>Optimization Type</td>
                      <td>Shallow comparison of props & state</td>
                      <td>Shallow comparison of props only</td>
                    </tr>
                    <tr>
                      <td>Syntax</td>
                      <td>class MyComp extends React.PureComponent</td>
                      <td>export default React.memo(MyComp)</td>
                    </tr>
                    <tr>
                      <td>Custom Comparison</td>
                      <td>No built-in custom comparison</td>
                      <td>Can pass custom comparison function</td>
                    </tr>
                    <tr>
                      <td>Modern Usage</td>
                      <td>Less preferred now</td>
                      <td>Preferred in modern React</td>
                    </tr>
                  </tbody>
                </table>

                <p><strong>Interview Tip:</strong> Prefer <code>React.memo</code> in modern React applications since functional components are the standard now.</p>

              </div>
            </div>
          </div>

        </div>

      </div>
    </div>
  </div>

</div>
