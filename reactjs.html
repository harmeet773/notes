---
layout: default
title: React.js
---

<h2 class="mb-3">React.js</h2>
<h3 class="mb-4">Interview Preparation Notes</h3>

<!-- =============================== -->
<!-- React Internal Working Section -->
<!-- =============================== -->

to do -- add 
add about suspense in react.js https://www.youtube.com/watch?v=wIyHSOugGGw&list=PPSV

and https://www.youtube.com/watch?v=6MYc-ZewjVU&list=PLkMY2Sn6ZX3m_YIbwL8vNos98pkpeIzaD&index=42 

redux thunk , redux saga ,
react routing , lazy loading , memorization  .



<div class="accordion mb-4" id="coreReactAccordion">
  <div class="accordion-item">
    <h2 class="accordion-header">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#reactInternals"
      >
        How React.js Works Internally (Core Concepts)
      </button>
    </h2>

    <div
      id="reactInternals"
      class="accordion-collapse collapse"
      data-bs-parent="#coreReactAccordion"
    >
      <div class="accordion-body">
        <h5>1Ô∏è‚É£ Virtual DOM</h5>
        <ul>
          <li>
            React creates a lightweight copy of the real DOM called the
            <strong>Virtual DOM</strong>.
          </li>
          <li>
            Whenever state or props change, React updates the Virtual DOM first.
          </li>
          <li>
            It compares the updated Virtual DOM with the previous version.
          </li>
        </ul>

        <h5>2Ô∏è‚É£ Diffing Algorithm (Reconciliation)</h5>
        <ul>
          <li>
            React uses a smart diffing algorithm to compare old and new Virtual
            DOM trees.
          </li>
          <li>
            Instead of re-rendering the entire DOM, React finds only the changed
            nodes.
          </li>
          <li>This process is called <strong>Reconciliation</strong>.</li>
          <li>React uses keys to efficiently track list changes.</li>
        </ul>

        <h5>3Ô∏è‚É£ Rendering Process</h5>
        <ul>
          <li>State/Props change ‚Üí Virtual DOM updates</li>
          <li>Diffing happens</li>
          <li>Only changed elements are updated in the real DOM</li>
          <li>This makes React fast and efficient.</li>
        </ul>

        <h5>4Ô∏è‚É£ Fiber Architecture</h5>
        <ul>
          <li>React Fiber is the internal engine of React.</li>
          <li>It allows incremental rendering.</li>
          <li>Supports features like Concurrent Mode.</li>
          <li>Improves UI responsiveness.</li>
        </ul>

        <h5>5Ô∏è‚É£ Why Babel is Used</h5>
        <ul>
          <li>Browsers do not understand JSX directly.</li>
          <li>Babel converts JSX into regular JavaScript that browsers can execute.</li>
          <li>Babel also transpiles modern ES6+ syntax to widely supported JavaScript.</li>
          <li>Often used together with Webpack via babel-loader.</li>
          <li>Example (JSX to JS):</li>
        </ul>

        <pre>JSX:
&lt;h1&gt;Hello&lt;/h1&gt;

Converted by Babel:
React.createElement("h1", null, "Hello");
</pre>

        <h5>6Ô∏è‚É£ Webpack in React (Bundling)</h5>
        <ul>
          <li>Webpack is a module bundler that builds a dependency graph starting from entry points.</li>
          <li>It bundles JS, CSS, images, etc., into optimized assets for the browser.</li>
          <li>Uses loaders to transform files (e.g., babel-loader for JSX/TS, css-loader/style-loader for CSS).</li>
          <li>Plugins extend capabilities (e.g., HtmlWebpackPlugin, DefinePlugin, MiniCssExtractPlugin).</li>
          <li>DevServer enables HMR (Hot Module Replacement) for fast local development.</li>
        </ul>

        <pre><code class="language-javascript">// webpack.config.js (basic example)
const path = require('path');

module.exports = {
  mode: 'development',
  entry: './src/index.jsx',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
    publicPath: '/',
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/i,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: { presets: ['@babel/preset-env', '@babel/preset-react'] }
        }
      },
      { test: /\.css$/i, use: ['style-loader', 'css-loader'] }
    ]
  },
  resolve: { extensions: ['.js', '.jsx'] },
  devServer: { historyApiFallback: true, hot: true }
};
</code></pre>

        <p><strong>Interview Tip:</strong> Create React App, Vite, and Next.js abstract Babel/Webpack (or use esbuild/rollup) behind the scenes, but understanding bundling and transpiling helps debug and optimize builds.</p>
      </div>
    </div>
  </div>
</div>

<!-- =============================== -->
<!-- Existing Accordion Below -->
<!-- =============================== -->

<div class="accordion" id="mainAccordion">
  <div class="accordion-item">
    <h2 class="accordion-header">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#reactSection"
      >
        React.js Specific Interview Questions
      </button>
    </h2>

    <div
      id="reactSection"
      class="accordion-collapse collapse"
      data-bs-parent="#mainAccordion"
    >
      <div class="accordion-body">
        <div class="accordion" id="reactSubAccordion">
          <!-- Functional vs Class -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#functional"
              >
                1. Functional vs Class Components
              </button>
            </h2>

            <div
              id="functional"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <ul>
                  <li>Class components use lifecycle methods.</li>
                  <li>Functional components use Hooks.</li>
                  <li>Modern React prefers functional components.</li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Hooks -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#hooks"
              >
                2. Hooks
              </button>
            </h2>

            <div
              id="hooks"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <div class="accordion" id="hooksNestedAccordion">
                  <!-- useState -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseState"
                      >
                        <h6 class="mb-0">1Ô∏è‚É£ useState</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseState"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Used to manage local component state.</li>
                          <li>Triggers re-render when state updates.</li>
                        </ul>

                        <pre><code>
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;button onClick={() => setCount(count + 1)}&gt;
      Count: {count}
    &lt;/button&gt;
  );
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useReducer -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseReducer"
                      >
                        <h6 class="mb-0">2Ô∏è‚É£ useReducer</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseReducer"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Used for complex state logic.</li>
                          <li>
                            Better for managing multiple related state values.
                          </li>
                          <li>Similar to Redux reducer pattern.</li>
                        </ul>

                        <pre><code>
  import { useReducer } from "react";

function reducer(state, action) {
  switch(action.type) {
    case "increment":
      return { count: state.count + 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    &lt;button onClick={() => dispatch({ type: "increment" })}&gt;
      Count: {state.count}
    &lt;/button&gt;
  );
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useContext -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseContext"
                      >
                        <h6 class="mb-0">3Ô∏è‚É£ useContext</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseContext"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Used to consume values from Context API.</li>
                          <li>Avoids prop drilling.</li>
                        </ul>

                        <pre><code>
import { useContext } from "react";
import { ThemeContext } from "./ThemeContext";

function Button() {
  const theme = useContext(ThemeContext);
  return &lt;button style={{ background: theme }}&gt;Click&lt;/button&gt;;
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useRef -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseRef"
                      >
                        <h6 class="mb-0">4Ô∏è‚É£ useRef</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseRef"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Access DOM elements directly.</li>
                          <li>Stores mutable values without re-rendering.</li>
                        </ul>

                        <pre><code>
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    &lt;&gt;
      &lt;input ref={inputRef} /&gt;
      &lt;button onClick={focusInput}&gt;Focus&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useEffect -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseEffect"
                      >
                        <h6 class="mb-0">5Ô∏è‚É£ useEffect</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseEffect"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>
                            Used for side effects (API calls, subscriptions,
                            timers).
                          </li>
                          <li>Runs after render.</li>
                          <li>Dependency array controls execution.</li>
                        </ul>

                        <pre><code>
import { useEffect, useState } from "react";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useMemo -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseMemo"
                      >
                        <h6 class="mb-0">6Ô∏è‚É£ useMemo</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseMemo"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Memoizes expensive computed values.</li>
                          <li>Prevents unnecessary recalculations.</li>
                        </ul>

                        <pre><code>
import { useMemo } from "react";

function Expensive({ num }) {
  const squared = useMemo(() => {
    console.log("Calculating...");
    return num * num;
  }, [num]);

  return &lt;p&gt;Result: {squared}&lt;/p&gt;;
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useCallback -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseCallback"
                      >
                        <h6 class="mb-0">7Ô∏è‚É£ useCallback</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseCallback"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Memoizes function references.</li>
                          <li>
                            Prevents unnecessary re-renders of child components.
                          </li>
                        </ul>

                        <pre><code>
import { useCallback } from "react";

function Parent() {
  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []);

  return &lt;Child onClick={handleClick} /&gt;;
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- Summary -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookSummary"
                      >
                        <h6 class="mb-0">üî• Interview Summary</h6>
                      </button>
                    </h2>
                    <div
                      id="hookSummary"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li><strong>useState</strong> ‚Üí Simple state</li>
                          <li>
                            <strong>useReducer</strong> ‚Üí Complex state logic
                          </li>
                          <li><strong>useContext</strong> ‚Üí Global data</li>
                          <li>
                            <strong>useRef</strong> ‚Üí DOM access / mutable
                            values
                          </li>
                          <li><strong>useEffect</strong> ‚Üí Side effects</li>
                          <li><strong>useMemo</strong> ‚Üí Memoize values</li>
                          <li>
                            <strong>useCallback</strong> ‚Üí Memoize functions
                          </li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>
                <!-- /#hooksNestedAccordion -->
              </div>
            </div>
          </div>

          <!-- Context API -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#context"
              >
                3. Context API
              </button>
            </h2>

            <div
              id="context"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <p>
                  Context API allows sharing global data without prop drilling.
                </p>
                <ul>
                  <li>Create using <code>React.createContext()</code></li>
                  <li>Wrap with <code>Provider</code></li>
                  <li>Consume using <code>useContext()</code></li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Pure vs Impure Components -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#pure"
              >
                4. Pure vs Impure Components
              </button>
            </h2>

            <div
              id="pure"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <h6>Pure Component</h6>
                <ul>
                  <li>Same output for same props & state.</li>
                  <li>No side effects inside render.</li>
                  <li>Predictable and easy to test.</li>
                </ul>

                <pre><code>
function Greeting({ name }) {
  return &lt;h1&gt;Hello {name}&lt;/h1&gt;;
}
</code></pre>

                <hr />

                <h6>Impure Component</h6>
                <ul>
                  <li>Output may change without prop/state change.</li>
                  <li>Uses external variables or random values.</li>
                </ul>

                <pre><code>
let count = 0;

function Counter() {
  count++;
  return &lt;h1&gt;Count: {count}&lt;/h1&gt;;
}
</code></pre>

                <hr />

                <h6>React.PureComponent vs React.memo</h6>

                <table class="table table-bordered">
                  <thead>
                    <tr>
                      <th>Feature</th>
                      <th>React.PureComponent</th>
                      <th>React.memo()</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Used With</td>
                      <td>Class Components</td>
                      <td>Functional Components</td>
                    </tr>
                    <tr>
                      <td>Optimization Type</td>
                      <td>Shallow comparison of props & state</td>
                      <td>Shallow comparison of props only</td>
                    </tr>
                    <tr>
                      <td>Syntax</td>
                      <td>class MyComp extends React.PureComponent</td>
                      <td>export default React.memo(MyComp)</td>
                    </tr>
                    <tr>
                      <td>Custom Comparison</td>
                      <td>No built-in custom comparison</td>
                      <td>Can pass custom comparison function</td>
                    </tr>
                    <tr>
                      <td>Modern Usage</td>
                      <td>Less preferred now</td>
                      <td>Preferred in modern React</td>
                    </tr>
                  </tbody>
                </table>

                <p>
                  <strong>Interview Tip:</strong> Prefer
                  <code>React.memo</code> in modern React applications since
                  functional components are the standard now.
                </p>
              </div>
            </div>
          </div>
          <!-- Portals -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#portals"
              >
                5. React Portals
              </button>
            </h2>

            <div
              id="portals"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <h6>What are Portals?</h6>
                <p>
                  Portals allow rendering a component outside its parent DOM
                  hierarchy while keeping it inside the same React component
                  tree.
                </p>

                <ul>
                  <li>Used for Modals, Tooltips, Dropdowns, Overlays.</li>
                  <li>Helps avoid CSS overflow / z-index issues.</li>
                  <li>Still supports event bubbling through React tree.</li>
                </ul>

                <hr />

                <h6>How Portals Work</h6>

                <p>
                  Instead of rendering inside <code>#root</code>, you render
                  into another DOM node.
                </p>

                <h6>Step 1: Add a div in index.html</h6>

                <pre><code>
&lt;div id="root"&gt;&lt;/div&gt;
&lt;div id="portal-root"&gt;&lt;/div&gt;
</code></pre>

                <h6>Step 2: Create Portal Component</h6>

                <pre><code>
import ReactDOM from "react-dom";

function Modal({ children }) {
  return ReactDOM.createPortal(
    &lt;div className="modal"&gt;
      {children}
    &lt;/div&gt;,
    document.getElementById("portal-root")
  );
}
</code></pre>

                <h6>Step 3: Use It</h6>

                <pre><code>
function App() {
  return (
    &lt;&gt;
      &lt;h1&gt;Main App&lt;/h1&gt;
      &lt;Modal&gt;
        &lt;p&gt;This is rendered using Portal&lt;/p&gt;
      &lt;/Modal&gt;
    &lt;/&gt;
  );
}
</code></pre>

                <hr />

                <h6>Key Interview Points</h6>

                <ul>
                  <li>Portals do NOT break React‚Äôs event bubbling.</li>
                  <li>They only change DOM placement, not React hierarchy.</li>
                  <li>Useful for UI layers (modals, popups).</li>
                </ul>

                <p>
                  <strong>Interview Tip:</strong> Portals solve UI layering
                  problems without breaking React‚Äôs component structure.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
