---
layout: default
title: React.js
---

<h2 class="mb-3">React.js</h2>
<h3 class="mb-4">Interview Preparation Notes</h3>

<!-- =============================== -->
<!-- React Internal Working Section -->
<!-- =============================== -->

<div class="accordion mb-4" id="coreReactAccordion">
  <div class="accordion-item">
    <h2 class="accordion-header">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#reactInternals"
      >
        How React.js Works Internally (Core Concepts)
      </button>
    </h2>

    <div
      id="reactInternals"
      class="accordion-collapse collapse"
      data-bs-parent="#coreReactAccordion"
    >
      <div class="accordion-body">
        <h5>1Ô∏è‚É£ Virtual DOM</h5>
        <ul>
          <li>
            React creates a lightweight copy of the real DOM called the
            <strong>Virtual DOM</strong>.
          </li>
          <li>
            Whenever state or props change, React updates the Virtual DOM first.
          </li>
          <li>
            It compares the updated Virtual DOM with the previous version.
          </li>
        </ul>

        <h5>2Ô∏è‚É£ Diffing Algorithm (Reconciliation)</h5>
        <ul>
          <li>
            React uses a smart diffing algorithm to compare old and new Virtual
            DOM trees.
          </li>
          <li>
            Instead of re-rendering the entire DOM, React finds only the changed
            nodes.
          </li>
          <li>This process is called <strong>Reconciliation</strong>.</li>
          <li>React uses keys to efficiently track list changes.</li>
        </ul>

        <h5>3Ô∏è‚É£ Rendering Process</h5>
        <ul>
          <li>State/Props change ‚Üí Virtual DOM updates</li>
          <li>Diffing happens</li>
          <li>Only changed elements are updated in the real DOM</li>
          <li>This makes React fast and efficient.</li>
        </ul>

        <h5>4Ô∏è‚É£ Fiber Architecture</h5>
        <ul>
          <li>React Fiber is the internal engine of React.</li>
          <li>It allows incremental rendering.</li>
          <li>Supports features like Concurrent Mode.</li>
          <li>Improves UI responsiveness.</li>
        </ul>

        <h5>5Ô∏è‚É£ Why Babel is Used</h5>
        <ul>
          <li>Browsers do not understand JSX directly.</li>
          <li>Babel converts JSX into regular JavaScript.</li>
          <li>Example:</li>
        </ul>

        <pre>
JSX:
&lt;h1&gt;Hello&lt;/h1&gt;

Converted by Babel:
React.createElement("h1", null, "Hello");
</pre
        >

        <ul>
          <li>
            Babel also converts modern ES6+ syntax to browser-compatible
            JavaScript.
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- =============================== -->
<!-- Existing Accordion Below -->
<!-- =============================== -->

<div class="accordion" id="mainAccordion">
  <div class="accordion-item">
    <h2 class="accordion-header">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#reactSection"
      >
        React.js Specific Interview Questions
      </button>
    </h2>

    <div
      id="reactSection"
      class="accordion-collapse collapse"
      data-bs-parent="#mainAccordion"
    >
      <div class="accordion-body">
        <div class="accordion" id="reactSubAccordion">
          <!-- Functional vs Class -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#functional"
              >
                1. Functional vs Class Components
              </button>
            </h2>

            <div
              id="functional"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <ul>
                  <li>Class components use lifecycle methods.</li>
                  <li>Functional components use Hooks.</li>
                  <li>Modern React prefers functional components.</li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Hooks -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#hooks"
              >
                2. Hooks
              </button>
            </h2>

            <div
              id="hooks"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <div class="accordion" id="hooksNestedAccordion">
                  <!-- useState -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseState"
                      >
                        <h6 class="mb-0">1Ô∏è‚É£ useState</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseState"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Used to manage local component state.</li>
                          <li>Triggers re-render when state updates.</li>
                        </ul>

                        <pre><code>
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;button onClick={() => setCount(count + 1)}&gt;
      Count: {count}
    &lt;/button&gt;
  );
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useReducer -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseReducer"
                      >
                        <h6 class="mb-0">2Ô∏è‚É£ useReducer</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseReducer"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Used for complex state logic.</li>
                          <li>Better for managing multiple related state values.</li>
                          <li>Similar to Redux reducer pattern.</li>
                        </ul>

                        <pre><code>
import { useReducer } from "react";

function reducer(state, action) {
  switch(action.type) {
    case "increment":
      return { count: state.count + 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    &lt;button onClick={() => dispatch({ type: "increment" })}&gt;
      Count: {state.count}
    &lt;/button&gt;
  );
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useContext -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseContext"
                      >
                        <h6 class="mb-0">3Ô∏è‚É£ useContext</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseContext"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Used to consume values from Context API.</li>
                          <li>Avoids prop drilling.</li>
                        </ul>

                        <pre><code>
import { useContext } from "react";
import { ThemeContext } from "./ThemeContext";

function Button() {
  const theme = useContext(ThemeContext);
  return &lt;button style={{ background: theme }}&gt;Click&lt;/button&gt;;
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useRef -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseRef"
                      >
                        <h6 class="mb-0">4Ô∏è‚É£ useRef</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseRef"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Access DOM elements directly.</li>
                          <li>Stores mutable values without re-rendering.</li>
                        </ul>

                        <pre><code>
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    &lt;&gt;
      &lt;input ref={inputRef} /&gt;
      &lt;button onClick={focusInput}&gt;Focus&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useEffect -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseEffect"
                      >
                        <h6 class="mb-0">5Ô∏è‚É£ useEffect</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseEffect"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Used for side effects (API calls, subscriptions, timers).</li>
                          <li>Runs after render.</li>
                          <li>Dependency array controls execution.</li>
                        </ul>

                        <pre><code>
import { useEffect, useState } from "react";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useMemo -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseMemo"
                      >
                        <h6 class="mb-0">6Ô∏è‚É£ useMemo</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseMemo"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Memoizes expensive computed values.</li>
                          <li>Prevents unnecessary recalculations.</li>
                        </ul>

                        <pre><code>
import { useMemo } from "react";

function Expensive({ num }) {
  const squared = useMemo(() => {
    console.log("Calculating...");
    return num * num;
  }, [num]);

  return &lt;p&gt;Result: {squared}&lt;/p&gt;;
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- useCallback -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookUseCallback"
                      >
                        <h6 class="mb-0">7Ô∏è‚É£ useCallback</h6>
                      </button>
                    </h2>
                    <div
                      id="hookUseCallback"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li>Memoizes function references.</li>
                          <li>Prevents unnecessary re-renders of child components.</li>
                        </ul>

                        <pre><code>
import { useCallback } from "react";

function Parent() {
  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []);

  return &lt;Child onClick={handleClick} /&gt;;
}
</code></pre>
                      </div>
                    </div>
                  </div>

                  <!-- Summary -->
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button
                        class="accordion-button collapsed"
                        type="button"
                        data-bs-toggle="collapse"
                        data-bs-target="#hookSummary"
                      >
                        <h6 class="mb-0">üî• Interview Summary</h6>
                      </button>
                    </h2>
                    <div
                      id="hookSummary"
                      class="accordion-collapse collapse"
                      data-bs-parent="#hooksNestedAccordion"
                    >
                      <div class="accordion-body">
                        <ul>
                          <li><strong>useState</strong> ‚Üí Simple state</li>
                          <li><strong>useReducer</strong> ‚Üí Complex state logic</li>
                          <li><strong>useContext</strong> ‚Üí Global data</li>
                          <li><strong>useRef</strong> ‚Üí DOM access / mutable values</li>
                          <li><strong>useEffect</strong> ‚Üí Side effects</li>
                          <li><strong>useMemo</strong> ‚Üí Memoize values</li>
                          <li><strong>useCallback</strong> ‚Üí Memoize functions</li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div> <!-- /#hooksNestedAccordion -->
              </div>
            </div>
          </div>

          <!-- Context API -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#context"
              >
                3. Context API
              </button>
            </h2>

            <div
              id="context"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <p>
                  Context API allows sharing global data without prop drilling.
                </p>
                <ul>
                  <li>Create using <code>React.createContext()</code></li>
                  <li>Wrap with <code>Provider</code></li>
                  <li>Consume using <code>useContext()</code></li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Pure vs Impure Components -->
          <div class="accordion-item">
            <h2 class="accordion-header">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#pure"
              >
                4. Pure vs Impure Components
              </button>
            </h2>

            <div
              id="pure"
              class="accordion-collapse collapse"
              data-bs-parent="#reactSubAccordion"
            >
              <div class="accordion-body">
                <h6>Pure Component</h6>
                <ul>
                  <li>Same output for same props & state.</li>
                  <li>No side effects inside render.</li>
                  <li>Predictable and easy to test.</li>
                </ul>

                <pre><code>
function Greeting({ name }) {
  return &lt;h1&gt;Hello {name}&lt;/h1&gt;;
}
</code></pre>

                <hr />

                <h6>Impure Component</h6>
                <ul>
                  <li>Output may change without prop/state change.</li>
                  <li>Uses external variables or random values.</li>
                </ul>

                <pre><code>
let count = 0;

function Counter() {
  count++;
  return &lt;h1&gt;Count: {count}&lt;/h1&gt;;
}
</code></pre>

                <hr />

                <h6>React.PureComponent vs React.memo</h6>

                <table class="table table-bordered">
                  <thead>
                    <tr>
                      <th>Feature</th>
                      <th>React.PureComponent</th>
                      <th>React.memo()</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Used With</td>
                      <td>Class Components</td>
                      <td>Functional Components</td>
                    </tr>
                    <tr>
                      <td>Optimization Type</td>
                      <td>Shallow comparison of props & state</td>
                      <td>Shallow comparison of props only</td>
                    </tr>
                    <tr>
                      <td>Syntax</td>
                      <td>class MyComp extends React.PureComponent</td>
                      <td>export default React.memo(MyComp)</td>
                    </tr>
                    <tr>
                      <td>Custom Comparison</td>
                      <td>No built-in custom comparison</td>
                      <td>Can pass custom comparison function</td>
                    </tr>
                    <tr>
                      <td>Modern Usage</td>
                      <td>Less preferred now</td>
                      <td>Preferred in modern React</td>
                    </tr>
                  </tbody>
                </table>

                <p>
                  <strong>Interview Tip:</strong> Prefer
                  <code>React.memo</code> in modern React applications since
                  functional components are the standard now.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
