---
layout: default
title: React.js
---

<h2>React.js</h2>

<h3>React.js Interview Preparation Notes</h3>

<div>    

  <h3>JavaScript Fundamentals (Very Important for React Interviews)</h3>

  <ul>

    <li>
      <strong>1. Arrow Function vs Normal Function</strong>

      <p><strong>Definition:</strong></p>
      <ul>
        <li>Arrow functions do not have their own <code>this</code>, <code>arguments</code>, <code>super</code>, or <code>new.target</code>.</li>
        <li>They inherit <code>this</code> from the surrounding (lexical) scope.</li>
      </ul>

      <p><strong>Why Important in React?</strong></p>
      <ul>
        <li>Avoids manual binding in class components.</li>
        <li>Commonly used in functional components and callbacks.</li>
      </ul>

      <p><strong>Interview Follow-up:</strong></p>
      <ul>
        <li>Why can't arrow functions be used as constructors?</li>
        <li>Why don’t arrow functions have their own <code>this</code>?</li>
      </ul>
    </li>

    <li>
      <strong>2. Closure</strong>

      <p><strong>Definition:</strong></p>
      <p>A closure is created when a function retains access to variables from its outer scope even after the outer function has finished execution.</p>

      <p><strong>Why Important?</strong></p>
      <ul>
        <li>Used in React Hooks internally.</li>
        <li>Important in debounce, throttle, and event handlers.</li>
      </ul>

      <p><strong>Common Question:</strong></p>
      <ul>
        <li>What is a stale closure in React?</li>
      </ul>
    </li>

    <li>
      <strong>3. Hoisting</strong>

      <p><strong>Definition:</strong></p>
      <p>Hoisting is JavaScript’s behavior of moving declarations to the top of their scope during compilation.</p>

      <ul>
        <li>Function declarations → Fully hoisted</li>
        <li><code>var</code> → Hoisted, initialized as <code>undefined</code></li>
        <li><code>let</code> & <code>const</code> → Hoisted but in Temporal Dead Zone (TDZ)</li>
      </ul>

      <pre><code>
console.log(a); // undefined
var a = 5;

console.log(b); // ReferenceError
let b = 10;
      </code></pre>
    </li>

    <li>
      <strong>4. Promises, Async & Await</strong>

      <p><strong>Promise States:</strong></p>
      <ul>
        <li>Pending</li>
        <li>Fulfilled</li>
        <li>Rejected</li>
      </ul>

      <p><strong>Why async/await?</strong></p>
      <ul>
        <li>Makes asynchronous code readable.</li>
        <li>Avoids promise chaining.</li>
      </ul>

      <p><strong>Interview Follow-up:</strong></p>
      <ul>
        <li>What happens if you don’t use <code>await</code>?</li>
        <li>Difference between <code>Promise.all</code> and <code>Promise.allSettled</code>?</li>
      </ul>
    </li>

  </ul>

  <hr />

  <h3>React Core Concepts</h3>

  <ul>

    <li>
      <strong>1. Functional vs Class Components</strong>

      <ul>
        <li>Class components use lifecycle methods.</li>
        <li>Functional components use Hooks.</li>
        <li>Modern React prefers functional components.</li>
      </ul>

      <p><strong>Important:</strong></p>
      <p>All features of class components can be implemented using functional components — but only with Hooks.</p>
    </li>

    <li>
      <strong>2. Hooks</strong>

      <ul>
        <li><code>useState</code> → Manage state</li>
        <li><code>useEffect</code> → Side effects</li>
        <li><code>useMemo</code> → Memoize computed values</li>
        <li><code>useCallback</code> → Memoize function references</li>
        <li><code>useRef</code> → Access DOM or persist values</li>
      </ul>

      <p><strong>Interview Question:</strong></p>
      <ul>
        <li>Why can't hooks be used inside loops or conditions?</li>
      </ul>
    </li>

    <li>
      <strong>3. Controlled vs Uncontrolled Components</strong>

      <ul>
        <li><strong>Controlled:</strong> Form data handled by React state.</li>
        <li><strong>Uncontrolled:</strong> Form data handled by DOM using refs.</li>
      </ul>
    </li>

    <li>
      <strong>4. Prop Drilling</strong>

      <p>Passing data through multiple nested components unnecessarily.</p>

      <p><strong>Solution:</strong> Context API or state management libraries.</p>
    </li>

    <li>
      <strong>5. Context API</strong>

      <p><strong>Definition:</strong></p>
      <p>Context API allows sharing global data across components without prop drilling.</p>

      <p><strong>When to Use:</strong></p>
      <ul>
        <li>Theme (dark/light mode)</li>
        <li>User authentication</li>
        <li>Language preference</li>
        <li>Small to medium global state</li>
      </ul>

      <p><strong>How to Use:</strong></p>

      <p><strong>Step 1: Create Context</strong></p>
      <pre><code>
import { createContext } from "react";
export const ThemeContext = createContext();
      </code></pre>

      <p><strong>Step 2: Provide Context</strong></p>
      <pre><code>
function App() {
  const [theme, setTheme] = useState("light");

  return (
    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
      &lt;Home /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}
      </code></pre>

      <p><strong>Step 3: Consume Context</strong></p>
      <pre><code>
function Home() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    &lt;div&gt;
      &lt;h1&gt;Theme: {theme}&lt;/h1&gt;
      &lt;button onClick={() => setTheme("dark")}&gt;
        Change Theme
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
      </code></pre>

      <p><strong>Performance Note:</strong></p>
      <ul>
        <li>All consumers re-render when context value changes.</li>
        <li>Not ideal for very frequent updates.</li>
      </ul>

      <p><strong>Interview Question:</strong></p>
      <ul>
        <li>Can Context API replace Redux?</li>
      </ul>
    </li>

    <li>
      <strong>6. Keys in React</strong>

      <ul>
        <li>Helps React identify changed elements.</li>
        <li>Should be stable and unique.</li>
        <li>Avoid using array index as key (unless list is static).</li>
      </ul>
    </li>

  </ul>

  <hr />

  <h3>Performance Optimization</h3>

  <ul>
    <li><strong>useMemo</strong> → Memoizes expensive values.</li>
    <li><strong>useCallback</strong> → Prevents unnecessary re-renders.</li>
    <li><strong>Debounce</strong> → Executes after inactivity.</li>
    <li><strong>Throttle</strong> → Executes at fixed intervals.</li>
  </ul>

  <hr />

  <h3>HTML & Web Basics</h3>

  <ul>
    <li>
      <strong>&lt;link&gt; vs &lt;a&gt;</strong>
      <ul>
        <li><code>&lt;link&gt;</code> → Used inside head for resources (CSS).</li>
        <li><code>&lt;a&gt;</code> → Used for navigation.</li>
      </ul>
    </li>
  </ul>

</div>
