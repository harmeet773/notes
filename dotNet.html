---
layout: default
title: dotNet
---

<h2 class="mb-3">.NET Core</h2>
<h3 class="mb-4">Interview Preparation Notes</h3>

<div class="accordion" id="dotnetMainAccordion">
  <!-- 1. Core Concepts -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingCore">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnCoreConcepts"
        aria-expanded="false"
        aria-controls="dnCoreConcepts"
      >
        1. Core Concepts
      </button>
    </h2>
    <div
      id="dnCoreConcepts"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingCore"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Cross-platform, open-source, high-performance framework for building
            modern apps.
          </li>
          <li>
            Unified platform (.NET 5+) for web, desktop, mobile, cloud, and
            microservices.
          </li>
          <li>
            CLR manages memory via GC, just-in-time compilation, and type
            safety.
          </li>
        </ul>
        <h6>SDK vs Runtime</h6>
        <ul>
          <li>
            <strong>SDK</strong>: includes compilers, tools, and runtime to
            build apps.
          </li>
          <li>
            <strong>Runtime</strong>: to run apps only; no compilers/dev tools.
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- 2. Project Structure & CLI -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingCLI">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnCLI"
        aria-expanded="false"
        aria-controls="dnCLI"
      >
        2. Project Structure & CLI
      </button>
    </h2>
    <div
      id="dnCLI"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingCLI"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            <code>Program.cs</code> with top-level statements (minimal hosting)
            in .NET 6+.
          </li>
          <li>
            <code>appsettings.json</code> for configuration per environment.
          </li>
          <li>
            Use <code>dotnet</code> CLI for creating, building, running, and
            publishing.
          </li>
        </ul>

        <pre><code class="language-bash">dotnet new webapi -n SampleApi
dotnet build
dotnet run
dotnet publish -c Release
</code></pre>
      </div>
    </div>
  </div>

  <!-- 3. Dependency Injection (DI) -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingDI">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnDI"
        aria-expanded="false"
        aria-controls="dnDI"
      >
        3. Dependency Injection (DI)
      </button>
    </h2>
    <div
      id="dnDI"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingDI"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <h6>IoC (Inversion of Control) Overview</h6>
        <ul>
          <li>IoC is a principle where control of object creation and dependency resolution is delegated to an external component (a container) instead of being handled by the objects themselves.</li>
          <li>Promotes loose coupling, testability, and separation of concerns.</li>
        </ul>

        <h6>DI (Dependency Injection)</h6>
        <ul>
          <li>DI is a specific way to implement IoC by supplying dependencies to a class (usually via constructor, sometimes via properties or methods) rather than creating them internally.</li>
          <li>ASP.NET Core includes a built-in IoC container to register and resolve services.</li>
        </ul>

        <h6>IoC vs DI</h6>
        <ul>
          <li>IoC is the broader principle (who controls object creation and flow).</li>
          <li>DI is a concrete technique to achieve IoC by injecting dependencies.</li>
        </ul>
        <p>Dependency Injection is the most common way to implement IoC, but other approaches include the Service Locator pattern, Factory pattern, Template Method pattern, and event-driven mechanisms. All of these shift control of object creation or execution flow away from the class itself.</p>

        <h6>Benefits</h6>
        <ul>
          <li>Loose coupling and cleaner architecture.</li>
          <li>Easier unit testing and mocking (swap implementations).</li>
          <li>Centralized configuration of lifetimes and implementations.</li>
        </ul>

        <h6>Registration & Lifetimes</h6>
        <ul>
          <li><strong>Singleton</strong> — one instance for app lifetime.</li>
          <li><strong>Scoped</strong> — one instance per request scope.</li>
          <li><strong>Transient</strong> — new instance every resolution.</li>
        </ul>

        <pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

// Register interfaces to implementations with lifetimes
builder.Services.AddSingleton&lt;ICache, MemoryCacheImpl&gt;();
builder.Services.AddScoped&lt;IRepository, EfRepository&gt;();
builder.Services.AddTransient&lt;INotifier, EmailNotifier&gt;();

var app = builder.Build();
app.Run();
</code></pre>

        <h6>Constructor Injection Example</h6>
        <pre><code class="language-csharp">public interface IGreeter { string Greet(string name); }
public class Greeter : IGreeter { public string Greet(string name) =&gt; $"Hello {name}"; }

// Registration
// builder.Services.AddScoped&lt;IGreeter, Greeter&gt;();

[ApiController]
[Route("api/[controller]")]
public class HelloController : ControllerBase
{
    private readonly IGreeter _greeter;
    public HelloController(IGreeter greeter) =&gt; _greeter = greeter;

    [HttpGet("{name}")]
    public string Get(string name) =&gt; _greeter.Greet(name);
}
</code></pre>

        <h6>Avoid Service Locator</h6>
        <ul>
          <li>Prefer constructor injection over resolving services imperatively from <code>IServiceProvider</code> within classes (service locator anti-pattern), which hides dependencies and complicates testing.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- 4. Configuration & Options Pattern -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingConfig">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnConfig"
        aria-expanded="false"
        aria-controls="dnConfig"
      >
        4. Configuration & Options Pattern
      </button>
    </h2>
    <div
      id="dnConfig"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingConfig"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Bind strongly-typed settings via <code>IOptions&lt;T&gt;</code> /
            <code>IOptionsMonitor&lt;T&gt;</code>.
          </li>
          <li>
            Support multiple configuration providers: JSON, env vars, user
            secrets, Azure Key Vault.
          </li>
        </ul>

        <pre><code class="language-json">{
  "Smtp": {
    "Host": "smtp.example.com",
    "Port": 587
  }
}
</code></pre>

        <pre><code class="language-csharp">builder.Services.Configure&lt;SmtpOptions&gt;(builder.Configuration.GetSection("Smtp"));

public class SmtpOptions { public string Host { get; set; } = ""; public int Port { get; set; } }
</code></pre>
      </div>
    </div>
  </div>

  <!-- 5. Middleware & Request Pipeline -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingMiddleware">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnMiddleware"
        aria-expanded="false"
        aria-controls="dnMiddleware"
      >
        5. Middleware & Request Pipeline
      </button>
    </h2>
    <div
      id="dnMiddleware"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingMiddleware"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Pipeline built from middleware: authentication, routing, endpoints,
            static files, etc.
          </li>
          <li>
            Order matters: place <code>UseRouting()</code> before
            <code>UseEndpoints()</code>, etc.
          </li>
        </ul>

        <pre><code class="language-csharp">var app = builder.Build();

app.UseHttpsRedirection();
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.Run();
</code></pre>
      </div>
    </div>
  </div>

  <!-- 6. Controllers & Routing -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingControllers">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnControllers"
        aria-expanded="false"
        aria-controls="dnControllers"
      >
        6. Controllers & Routing
      </button>
    </h2>
    <div
      id="dnControllers"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingControllers"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Attribute routing with tokens like
            <code>[Route("api/[controller]")]</code>.
          </li>
          <li>
            Use <code>ApiController</code> for automatic 400 responses and
            binding behaviors.
          </li>
        </ul>

        <pre><code class="language-csharp">[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet("{id:int}")]
    public ActionResult&lt;UserDto&gt; Get(int id) =&gt; Ok(new UserDto(id, "John"));
}
</code></pre>
      </div>
    </div>
  </div>

  <!-- 7. Model Binding & Validation -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingModel">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnModel"
        aria-expanded="false"
        aria-controls="dnModel"
      >
        7. Model Binding & Validation
      </button>
    </h2>
    <div
      id="dnModel"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingModel"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Automatic binding from route, query, headers, and body to action
            parameters.
          </li>
          <li>
            Use DataAnnotations like <code>[Required]</code>,
            <code>[EmailAddress]</code>, <code>[Range]</code>.
          </li>
        </ul>

        <pre><code class="language-csharp">public record RegisterDto(
  [property: Required, EmailAddress] string Email,
  [property: Required, MinLength(6)] string Password);
</code></pre>
      </div>
    </div>
  </div>

  <!-- 8. Access Modifiers & Non-Access Modifiers -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingAccess">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnAccess"
        aria-expanded="false"
        aria-controls="dnAccess"
      >
        8. Access Modifiers & Non-Access Modifiers
      </button>
    </h2>
    <div
      id="dnAccess"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingAccess"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <h6>Access Modifiers (Visibility/Accessibility)</h6>
        <ul>
          <li><strong>public</strong> — Accessible from anywhere.</li>
          <li><strong>private</strong> — Accessible only within the containing type.</li>
          <li><strong>protected</strong> — Accessible within the containing type and derived types.</li>
          <li><strong>internal</strong> — Accessible within the same assembly.</li>
          <li><strong>protected internal</strong> — Accessible from the same assembly OR from derived types in any assembly.</li>
          <li><strong>private protected</strong> — Accessible from the containing type or its derived types in the same assembly.</li>
        </ul>

        <pre><code class="language-csharp">public class A
{
  private int x;
  protected int y;
  internal int z;
  protected internal int p;
  private protected int q;
}

public class B : A
{
  void Test() {
    // x not accessible (private)
    y = 1;  // protected OK
    z = 2;  // internal OK if same assembly
    p = 3;  // protected internal OK
    q = 4;  // private protected OK if same assembly
  }
}
</code></pre>

        <h6>Non-Access Modifiers (Behavior/Semantics)</h6>
        <ul>
          <li><strong>static</strong> — Member/type belongs to the type itself; one shared instance.</li>
          <li><strong>readonly</strong> — Field can be assigned only at declaration or in constructor.</li>
          <li><strong>const</strong> — Compile-time constant; implicitly static; must be assigned at declaration.</li>
          <li><strong>sealed</strong> — Class cannot be inherited; method cannot be overridden further.</li>
          <li><strong>abstract</strong> — Incomplete class/member; must be implemented by derived classes.</li>
          <li><strong>virtual</strong> — Member can be overridden in derived classes.</li>
          <li><strong>override</strong> — Provides a new implementation of a virtual/abstract member.</li>
          <li><strong>partial</strong> — Type/Method split across files; combined at compile time.</li>
          <li><strong>ref/out/in</strong> — Parameter passing modifiers: by reference, output-only, by-ref readonly.</li>
          <li><strong>async</strong> — Marks a method that contains await; returns Task/Task&lt;T&gt;/ValueTask.</li>
        </ul>

        <pre><code class="language-csharp">public static class MathUtil
{
  public const double Pi = 3.14159;
  public static int Square(int x) =&gt; x * x;
}

public abstract class Animal
{
  public abstract void Speak();
  public virtual void Move() =&gt; Console.WriteLine("Moving...");
}

public sealed class Dog : Animal
{
  public override void Speak() =&gt; Console.WriteLine("Woof");
  public override void Move() =&gt; Console.WriteLine("Running...");
}

public class Sample
{
  public readonly Guid Id = Guid.NewGuid();
  public void Update(ref int a, out int b, in int c)
  {
    a += c;
    b = a * 2; // out must be assigned
    // c is readonly by-ref
  }

  public async Task&lt;string&gt; FetchAsync() =&gt; await Task.FromResult("ok");
}
</code></pre>
      </div>
    </div>
  </div>

  <!-- 9. Entity Framework Core -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingEf">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnEf"
        aria-expanded="false"
        aria-controls="dnEf"
      >
        9. Entity Framework Core (EF Core)
      </button>
    </h2>
    <div
      id="dnEf"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingEf"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            ORM for data access with LINQ; supports migrations and change
            tracking.
          </li>
          <li>
            DbContext configured via DI; providers: SQL Server, SQLite,
            PostgreSQL, etc.
          </li>
        </ul>

        <pre><code class="language-csharp">builder.Services.AddDbContext&lt;AppDbContext&gt;(o =&gt;
    o.UseSqlServer(builder.Configuration.GetConnectionString("Default")));

public class AppDbContext : DbContext
{
  public AppDbContext(DbContextOptions options) : base(options) {}
  public DbSet&lt;User&gt; Users =&gt; Set&lt;User&gt;();
}
</code></pre>

        <h6>3. How do you perform migrations in EF?</h6>
        <p>For EF Core, you can use either the Package Manager Console (PMC) or the .NET CLI to manage migrations.</p>
        <ul>
          <li>PMC: <code>Add-Migration InitialCreate</code>, <code>Update-Database</code></li>
          <li>CLI: <code>dotnet ef migrations add InitialCreate</code>, <code>dotnet ef database update</code></li>
        </ul>
        <p>For EF6 (the classic Entity Framework for .NET Framework), migrations are handled via the Package Manager Console only.</p>
      </div>
    </div>
  </div>

  <!-- 9. Asynchronous Programming -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingAsync">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnAsync"
        aria-expanded="false"
        aria-controls="dnAsync"
      >
        9. Asynchronous Programming
      </button>
    </h2>
    <div
      id="dnAsync"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingAsync"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Use async/await to free threads; avoid blocking with
            <code>.Result</code>/<code>.Wait()</code>.
          </li>
          <li>
            Use <code>CancellationToken</code> for cooperative cancellation.
          </li>
        </ul>

        <pre><code class="language-csharp">[HttpGet]
public async Task&lt;IEnumerable&lt;UserDto&gt;&gt; GetAll(CancellationToken ct) =&gt;
    await _svc.GetUsersAsync(ct);
</code></pre>
      </div>
    </div>
  </div>

  <!-- 10. Logging & Monitoring -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingLogging">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnLogging"
        aria-expanded="false"
        aria-controls="dnLogging"
      >
        10. Logging & Monitoring
      </button>
    </h2>
    <div
      id="dnLogging"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingLogging"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Built-in logging abstractions with providers (Console, Debug, Seq,
            Application Insights).
          </li>
          <li>Use scopes and structured logging for richer context.</li>
        </ul>

        <pre><code class="language-csharp">public class UsersController(ILogger&lt;UsersController&gt; logger) : ControllerBase
{
  [HttpGet]
  public IActionResult Get() {
    using (logger.BeginScope("RequestId:{RequestId}", Guid.NewGuid())) {
      logger.LogInformation("Fetching users");
      return Ok(Array.Empty&lt;string&gt;());
    }
  }
}
</code></pre>
      </div>
    </div>
  </div>

  <!-- 11. Testing -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingTesting">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnTesting"
        aria-expanded="false"
        aria-controls="dnTesting"
      >
        11. Testing
      </button>
    </h2>
    <div
      id="dnTesting"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingTesting"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Use xUnit/NUnit/MSTest for unit tests; Moq/NSubstitute for mocking.
          </li>
          <li>
            WebApplicationFactory enables integration testing of minimal APIs
            and MVC.
          </li>
        </ul>

        <pre><code class="language-csharp">public class ApiTests : IClassFixture&lt;WebApplicationFactory&lt;Program&gt;&gt;
{
  private readonly HttpClient _client;
  public ApiTests(WebApplicationFactory&lt;Program&gt; factory) =&gt; _client = factory.CreateClient();

  [Fact]
  public async Task Get_ReturnsOk() {
    var res = await _client.GetAsync("/weatherforecast");
    res.EnsureSuccessStatusCode();
  }
}
</code></pre>
      </div>
    </div>
  </div>

  <!-- 12. Security & Identity -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingSecurity">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnSecurity"
        aria-expanded="false"
        aria-controls="dnSecurity"
      >
        12. Security & Identity
      </button>
    </h2>
    <div
      id="dnSecurity"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingSecurity"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <ul>
          <li>
            Use ASP.NET Core Identity or external providers (JWT/OAuth/OpenID
            Connect).
          </li>
          <li>
            Protect APIs with authentication/authorization policies and
            role-based access.
          </li>
        </ul>

        <pre><code class="language-csharp">builder.Services
  .AddAuthentication("Bearer")
  .AddJwtBearer("Bearer", o =&gt; {
    o.Authority = "https://auth.example.com";
    o.Audience = "api";
  });

app.UseAuthentication();
app.UseAuthorization();   
</code></pre>
      </div>
    </div>
  </div>

  <!-- 13. Self Study -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingSelfStudy">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnSelfStudy"
        aria-expanded="false"
        aria-controls="dnSelfStudy"
      >
        13. Self Study
      </button>
    </h2>
    <div
      id="dnSelfStudy"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingSelfStudy"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">
        <p>
          <a
            href="https://www.youtube.com/watch?v=rUtWgEs07eI"
            target="_blank"
            rel="noopener"
            >https://www.youtube.com/watch?v=rUtWgEs07eI</a
          >
        </p>

        <div class="accordion" id="dnSelfStudyAccordion">
          <div class="accordion-item">
            <h2 class="accordion-header" id="dnHeadingScaffolding">
              <button
                class="accordion-button collapsed"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#dnScaffolding"
                aria-expanded="false"
                aria-controls="dnScaffolding"
              >
                What is Scaffolding? How does it work in .NET?
              </button>
            </h2>

            <div
              id="dnScaffolding"
              class="accordion-collapse collapse"
              aria-labelledby="dnHeadingScaffolding"
              data-bs-parent="#dnSelfStudyAccordion"
            >
              <div class="accordion-body">
                <p>
                  <strong>Scaffolding in .NET (especially ASP.NET Core)</strong>
                  automatically generates code for common CRUD operations,
                  controllers, views, and UI pages based on your models. It
                  speeds up development by providing a ready-to-use skeleton you
                  can customize.
                </p>

                <p><strong>Scaffolding automates creation of:</strong></p>
                <ul>
                  <li>
                    <strong>Controllers</strong> – Handle HTTP requests and
                    responses.
                  </li>
                  <li>
                    <strong>Views</strong> – Razor Pages or MVC Views for
                    listing, editing, creating, and deleting records.
                  </li>
                  <li>
                    <strong>Data Access Code</strong> – Can include DbContext
                    and model binding if needed.
                  </li>
                  <li>
                    <strong>CRUD Methods</strong> – Pre-built methods for
                    Create, Read, Update, Delete operations.
                  </li>
                </ul>

                <p>
                  Essentially, it creates a template structure based on your
                  models. By providing Models as input, you can generate
                  controller and views code.
                </p>

                <p>In <strong>ASP.NET Core</strong>, scaffolding can generate:</p>

                <ul>
                  <li>
                    <strong>MVC scaffolding</strong> → Multiple views +
                    centralized controller → Better for complex applications.
                  </li>
                  <li>
                    <strong>Razor Pages scaffolding</strong> → Each page has its
                    own code-behind → Simpler for page-focused applications.
                  </li>
                  <li>
                    <strong>RESTful API scaffolding</strong> → Generates API
                    controllers with CRUD endpoints.
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <h6>Razor Pages</h6>
        <p>
          MVC and Razor Pages are two different approaches (they can be used
          together). MVC is an architectural pattern, whereas Razor Pages is a
          framework feature/programming model.
        </p>
        <p>
          Razor Pages is a page-based programming model in ASP.NET Core that
          simplifies building web apps compared to traditional MVC.
        </p>
        <p>
          Razor Pages are <code>.cshtml</code> files (views) with an associated
          Page Model (<code>.cshtml.cs</code>) that contains the C# code. They
          combine UI and logic for a single page in a self-contained structure,
          ideal for simple CRUD or page-focused applications.
        </p>

        <p><strong>Each Razor Page has two parts:</strong></p>
        <ul>
          <li><code>.cshtml</code> → HTML and Razor markup (the view)</li>
          <li><code>.cshtml.cs</code> → Page Model (code-behind)</li>
        </ul>

        <h6>DbContext (EF Core)</h6>
        <p>
          In ASP.NET Core with Entity Framework (EF) Core, a
          <code>DbContext</code> manages your database connection and
          operations—the bridge between your app code and the database.
        </p>
        <ol>
          <li>
            <strong>Definition</strong> — Represents a session with the
            database, enables querying/saving, and tracks changes for
            persistence. Implement by creating a class inheriting from
            <code>DbContext</code>.
          </li>
          <li>
            <strong>Key Components</strong>
            <ul>
              <li>
                <code>DbSet&lt;T&gt;</code> — Represents a table; each DbSet
                corresponds to an entity/model.
              </li>
              <li>
                <code>OnModelCreating</code> (optional) — Configure
                relationships/constraints via Fluent API.
              </li>
            </ul>
          </li>
        </ol>

        <h6>.NET Authentication (Built-in)</h6>
        <p>
          .NET provides built-in support for three common authentication
          mechanisms:
        </p>
        <ol>
          <li>
            <strong>Individual User Accounts</strong>
            <ul>
              <li>
                Classic form-based authentication using ASP.NET Core Identity.
              </li>
              <li>
                Features: registration, login, password hashing, email
                confirmation, password reset, roles.
              </li>
              <li>
                Use case: Consumer apps where users create accounts (blogs,
                e-commerce, portals).
              </li>
              <li>
                How it works: Credentials verified by Identity → cookie issued
                for session; user data stored in DB.
              </li>
            </ul>
          </li>
          <li>
            <strong>Microsoft Identity Platform (Azure AD)</strong>
            <ul>
              <li>Users log in with Microsoft work/school accounts.</li>
              <li>
                Features: SSO, MFA, Microsoft Graph integration, OAuth
                2.0/OpenID Connect tokens.
              </li>
              <li>Use case: Enterprise/internal applications.</li>
              <li>
                How it works: App redirects to Microsoft login → token returned
                → app calls APIs securely.
              </li>
            </ul>
          </li>
          <li>
            <strong>Windows Authentication</strong>
            <ul>
              <li>
                Uses existing Windows credentials (Active Directory); no login
                form.
              </li>
              <li>Features: Kerberos/NTLM; suitable for intranet apps.</li>
              <li>Use case: Internal tools within the same domain/network.</li>
              <li>
                How it works: Browser sends Windows credentials → verified
                against AD → user logged in.
              </li>
            </ul>
          </li>
        </ol>
        <h6>ADO.NET vs Code-First vs Database-First</h6>
        <p>
          <strong>ADO.NET</strong> requires manual SQL and data
          handling—fine-grained control but more boilerplate.
        </p>
        <p>
          <strong>Entity Framework Code-First</strong> defines the database with
          C# classes, automates CRUD and migrations, and improves
          maintainability.
        </p>
        <p>
          <strong>Entity Framework Database-First</strong> starts from an
          existing DB—EF generates models and <code>DbContext</code> from
          schema. Relationships/keys are scaffolded; DB changes require
          regenerating/updating models. CRUD via EF similar to Code-First.
        </p>
        <p>
          Visual Studio provides an in-built database designer to create a DB
          and generate entity models.
        </p>

        <h6>How to use Visual Studio Database Designer (SQL Server)</h6>
        <ol>
          <li>
            Create a database using “SQL Server Database Project” or use an
            existing one.
          </li>
          <li>
            To create a new DB: File → New → Project → SQL Server Database
            Project.
          </li>
        </ol>
      </div>
    </div>
  </div>

  <!-- 14. Interview Questions -->
  <div class="accordion-item">
    <h2 class="accordion-header" id="dnHeadingInterview">
      <button
        class="accordion-button collapsed"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#dnInterview"
        aria-expanded="false"
        aria-controls="dnInterview"
      >
        14. Interview Questions
      </button>
    </h2>
    <div
      id="dnInterview"
      class="accordion-collapse collapse"
      aria-labelledby="dnHeadingInterview"
      data-bs-parent="#dotnetMainAccordion"
    >
      <div class="accordion-body">

        <table>

            <thead>

                <tr>

                    <th>.NET Core vs .NET Framework</th>

                </tr>

                <tr>

                    <th>Feature</th>

                    <th>.NET Framework</th>

                    <th>.NET Core</th>

                </tr>

            </thead>

            <tbody>
                <tr>
                    <td><strong>Platform support</strong></td>
                    <td>Windows only</td>
                    <td>Cross-platform (Windows, Linux, macOS)</td>
                </tr>
                <tr>
                    <td><strong>Type of apps</strong></td>
                    <td>Web Forms, WPF, WinForms, ASP.NET MVC</td>
                    <td>ASP.NET Core, Console apps, Microservices, Cloud apps</td>
                </tr>
                <tr>
                    <td><strong>Open Source</strong></td>
                    <td>Partially</td>
                    <td>Fully open source (on GitHub)</td>
                </tr>
                <tr>
                    <td><strong>Performance</strong></td>
                    <td>Slower (IIS dependent)</td>
                    <td>Faster, modular, lightweight</td>
                </tr>
                <tr>
                    <td><strong>Deployment</strong></td>
                    <td>Installed system-wide</td>
                    <td>Self-contained, per-app deployment possible</td>
                </tr>
                <tr>
                    <td><strong>CLI support</strong></td>
                    <td>Limited</td>
                    <td>Full CLI (dotnet) support</td>
                </tr>
                <tr>
                    <td><strong>Versioning</strong></td>
                    <td>System-wide</td>
                    <td>Per-application, avoids version conflicts</td>
                </tr>
                <tr>
                    <td><strong>Web Server</strong></td>
                    <td>IIS only</td>
                    <td>Kestrel (built-in), can run behind IIS/Nginx/Apache</td>
                </tr>
                <tr>
                    <td><strong>Modern Development</strong></td>
                    <td>Not evolving (last 4.8)</td>
                    <td>.NET (.NET 6/7/8): Actively evolving</td>
                </tr>
            </tbody>
        </table>

        <h6>1) Which .NET version are you using?</h6>
        <p>Ans — .NET 6 (LTS). .NET 6 released Nov 9, 2021; .NET 8 (LTS) released Nov 14, 2023.</p>

        <h6>2) What is Dependency Injection (DI) and how does it work?</h6>
        <p>Explain DI as providing dependencies to classes via constructors or properties, managed by the built-in IoC container registered in Program.cs using service lifetimes.</p>

        <h6>3) Explain Transient vs Scoped vs Singleton DI</h6>
        <ul>
          <li><strong>AddTransient</strong> — New instance every time the service is requested. Not stored; each request/consumer gets a fresh instance, even within the same HTTP request.</li>
          <li><strong>AddScoped</strong> — One instance per request scope. Same instance reused for the duration of a single HTTP request.</li>
          <li><strong>AddSingleton</strong> — Single instance for the lifetime of the application. Reused across all requests; effectively stored statically.</li>
        </ul>
        <p>These three lifetimes control how long service instances live in ASP.NET Core DI.</p>

        <h6>4) How do you change object values in DI when required?</h6>
        <p>Use options pattern (<code>IOptionsMonitor&lt;T&gt;</code>) for config reloads, or inject a factory (<code>IServiceProvider</code> or custom <code>Func&lt;T&gt;</code>) to resolve fresh instances; for scoped state, use scoped services or <code>IMemoryCache</code>.</p>
        <h6>5) How do you handle exceptions in .NET Core APIs?</h6>
        <ul>
          <li><strong>Try–Catch</strong> — Local handling within actions or services to return meaningful errors.</li>
          <li><strong>Custom Middleware</strong> — Centralized global handler to standardize error responses and logging.</li>
          <li><strong>UseExceptionHandler()</strong> — Built-in global handler routing errors to a specific endpoint.</li>
        </ul>
        <h6>6) What is middleware and its uses?</h6>
        <p>Requests pass through a sequence of middleware; each can process the request, call the next middleware, or short-circuit. Responses flow back in reverse order.</p>
        <ul>
          <li>Common uses: Authentication/Authorization, Logging, Exception handling, CORS, Static files, Localization.</li>
        </ul>
        <h6>7) How do you classify exceptions and create custom exceptions?</h6>
        <p>Exceptions are runtime errors derived from <code>System.Exception</code>. System exceptions are predefined (e.g., NullReferenceException, FileNotFoundException). Custom exceptions derive from <code>Exception</code> for domain-specific errors.</p>
        Exceptions are runtime errors that occur during program execution — for example, dividing by zero, accessing null objects, or reading missing files.
They are objects derived from the System.Exception base class.

System exceptions → predefined runtime errors (e.g., NullReferenceException, FileNotFoundException).Custom exceptions → user-defined classes derived from Exception for handling application-specific errors.

        <h6>8) Which Entity Framework approach do you use? (Database First / Code First)</h6>
        <p>Answer based on project: Code-First for greenfield with migrations; Database-First for existing schemas.</p>

        <h6>9) How do you write queries – LINQ, raw SQL, or other approaches?</h6>
        <p>LINQ describes the data shape (filters, sorts, joins) while the ORM (EF) translates LINQ into SQL and executes it. Use raw SQL for complex or performance-critical cases.</p>
        we can write with LINQ , 

LINQ provides the language for writing queries,
ORM (like Entity Framework) provides the engine that runs those queries on the database.

LINQ --- Describes what data you want in a query (e.g., filtering, sorting, joining).

ORM (EF) -- Executes that query against the database by converting LINQ expressions into SQL.
      </div>
    </div>
  </div>
</div>

https://www.youtube.com/watch?v=Aa5ARJRWaEs .net core introduced in 2002 was
used only for windows platforms .net core introduced in 2016 and was cross
platform and had modular Architecture ( only the library used was included , not
all library ). .net 5 introduced in 2020 - it unified .net under one platform (
.net core and xamrin ). .net introduced in 2023 had AOT( ahead of time
compilation ) feature - code is compiled in native code elimination the need for
JIT( just in compilation ) compilation. from 40 minutes it explains oops. add
about library such as dapper , newtonsoft.json
