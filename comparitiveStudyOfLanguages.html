---
layout: default
title: Comparitive Study Of syntax of  Languages 
---

The purpose of the page is to serve as a quick reference guide for syntax.

<p>JavaScript’s <code>ToBoolean</code> operation converts any expression into a boolean.  
The <code>while( expr)</code> loop runs only when <code>ToBoolean(expr) === true</code>is true.</p>

<a class="btn btn-link" data-bs-toggle="HowJSConvertsExpressionsInBollean" href="#HowJSConvertsExpressionsInBollean?">
  Show / Hide Info
</a>  
<div id="HowJSConvertsExpressionsInBollean" class="collapse"></div>
<div class="mb-4">
  <h5 class="mb-3">JavaScript’s falsy values</h5>
  <p>There are only a handful of falsy values:</p>

  <ul class="list-group mb-3">
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <code>false</code>
      <span class="badge bg-secondary">boolean</span>
    </li>
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <code>0</code>
      <span class="badge bg-secondary">number</span>
    </li>
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <code>-0</code>
      <span class="badge bg-secondary">negative zero</span>
    </li>
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <code>0n</code>
      <span class="badge bg-secondary">BigInt zero</span>
    </li>
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <code>""</code>
      <span class="badge bg-secondary">empty string</span>
    </li>
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <code>null</code>
      <span class="badge bg-secondary">null</span>
    </li>
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <code>undefined</code>
      <span class="badge bg-secondary">undefined</span>
    </li>
    <li class="list-group-item d-flex justify-content-between align-items-center">
      <code>NaN</code>
      <span class="badge bg-secondary">Not-a-Number</span>
    </li>
  </ul>

  <p><strong>Note:</strong> Everything else—objects, arrays, functions, non-empty strings, and non-zero numbers—is <strong>truthy</strong>.</p>
</div>


slice - js
<p>In JavaScript, slice() is used to extract a portion of an array or string without modifying the original.
It works on arrays and strings.  It does not modifies original.</p>
<pre>array.slice(start, end); string.slice(start,end) </pre>


<div class="mb-4">
  <h3 class="h4">JavaScript Data Types and How They Are Stored</h3>
  <p class="text-muted">Understanding the difference between primitive values and objects in memory.</p>

  <table class="table table-bordered table-striped mt-3">
    <thead class="table-light">
      <tr>
        <th>Type</th>
        <th>Example</th>
        <th>What variable stores?</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Primitive</strong> (string, number, boolean, null, undefined, bigint, symbol)</td>
        <td><code>"har"</code>, <code>10</code>, <code>true</code></td>
        <td><strong>The actual value itself</strong></td>
      </tr>
      <tr>
        <td><strong>Object</strong> (array, function, object)</td>
        <td><code>{}</code>, <code>[]</code>, <code>function(){}</code></td>
        <td><strong>A reference (pointer) to the object</strong></td>
      </tr>
    </tbody>
  </table>
</div>


Array / List 

array -js 
<p>In JavaScript, any non promitive data type is a kind of object hence ,arrays are a special kind of object, which is why  -
<code> [1,3]  is // "object" </code>
</p>
js - iterations methods 
<p>
In JavaScript, the for...of loop is used to iterate over the values of an iterable object,
such as an array, string, Map, or Set. 
It gives you direct access to each element’s value,
making it ideal when you only care about the data itself.
On the other hand, the for...in loop is used to iterate over the keys (or property names) of an object. It’s commonly used for looping through object properties rather than array elements. While for...in works with objects and returns the keys as strings, for...of works with iterables and returns their actual values. Therefore, for...of is better suited for arrays and other iterable structures, while for...in is typically used for plain JavaScript objects.
<pre>
<code>
const arr = ["a", "b", "c"];
for (const x of arr) console.log(x); // a, b, c
for (const x in arr) console.log(x); // 0, 1, 2
</code>
</pre>
</p>
array and operations on array - js 
<p>
<pre>
<code>
const fruits = ["apple", "banana", "mango"];
console.log(fruits.includes("banana")); // true
console.log(fruits.includes("ban"));  // false , full element should match
console.log(fruits.shift()); //	Removes the first element of an array, and returns that element
console.log(fruits.unshift()); // Adds new elements to the beginning of an array, and returns the new length
console.log(fruits.push("orange")); // push() → Add element at the END
console.log(fruits.pop());  // Returns removed element -> "orange"
</code></pre></p>
spread and rest operator (...)
<table>
<thead>
<tr>
<th>Concept</th>
<th>Spread (<code>...</code>)</th>
<th>Rest (<code>...</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Purpose</strong></td>
<td>Expand/expand elements of an iterable (array, object, string) into individual elements.</td>
<td>Collect multiple elements/arguments into a single array or collect remaining properties.</td>
</tr>
<tr>
<td><strong>Typical syntax</strong></td>
<td><code>[...arr]</code>, <code>{...obj}</code>, <code>fn(...args)</code></td>
<td><code>function f(...args)</code>, <code>const { a, ...rest } = obj</code></td>
</tr>
<tr>
<td><strong>Used in</strong></td>
<td>Array literals, object literals, function calls, iterable expansions.</td>
<td>Function parameters, array/object destructuring to gather remaining items.</td>
</tr>
<tr>
<td><strong>Result</strong></td>
<td>Produces individual elements (does not create nested arrays unless element is nested).</td>
<td>Creates an array of the remaining arguments/items or an object with remaining props.</td>
</tr>
<tr>
<td><strong>Mutates original?</strong></td>
<td>No — creates new arrays/objects when used in literals or calls.</td>
<td>No — creates a new array/object holding collected values.</td>
</tr>
<tr>
<td><strong>When to prefer</strong></td>
<td>When you need to merge or expand values (e.g., shallow-copy arrays, pass array as args).</td>
<td>When you want to accept variable number of args or extract "rest" fields in destructuring.</td>
</tr>
</tbody>
</table>

type conversion in js
String(numerial value) // to conver into string 
Number(string_value) // ro convert into number
<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Direction</th>
      <th>Converts</th>
      <th>Example</th>
      <th>Output</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>toString()</code></td>
      <td>Number → String</td>
      <td>Converts any value to string</td>
      <td><code>(123).toString()</code></td>
      <td><code>"123"</code></td>
      <td>string</td>
    </tr>
    <tr>
      <td><code>parseInt()</code></td>
      <td>String → Number</td>
      <td>Converts string to integer</td>
      <td><code>parseInt("123")</code></td>
      <td><code>123</code></td>
      <td>number</td>
    </tr>
    <tr>
      <td><code>parseFloat()</code></td>
      <td>String → Number</td>
      <td>Converts string to float</td>
      <td><code>parseFloat("12.5")</code></td>
      <td><code>12.5</code></td>
      <td>number</td>
    </tr>
  </tbody>
</table>


operators - js

% - The % operator is the remainder (modulus) operator.
/ - The / operator in JavaScript is the division operator.
console.log(7 / 2);   // 3.5  
const quotient = Math.floor(7 / 2); // to get quotient 

Not operator - 
In JavaScript, there is no dedicated not keyword — but the same logic is done using the logical NOT operator i.e !
in js we could use Double NOT (!!) to converts any value to its boolean equivalent.


Set - js 

let mySet = new Set();
//  .add(value)  , .delete(value) , .has(value) , .clear() , .size
mySet.add(10);
mySet.add(20);
mySet.add(10); // duplicate, ignored
console.log(mySet);       // Set(2) {10, 20}
console.log(mySet.size);  // 2

map  - js 
<p>we can also use js object as map.but objects only accept string or symbol keys — not other data types.</p>
<pre>
<code>
const map = new Map();
// Add key-value pairs
map.set('name', 'Harmeet');
map.set('age', 25);
map.set(true, 'Yes'); // can use boolean as key

// Get a value
console.log(map.get('name')); // "Harmeet"

// Check if key exists
console.log(map.has('age')); // true

// Delete a key
map.delete('age');

// Get map size
console.log(map.size); // 2

// Iterate through entries
for (const [key, value] of map) {
  console.log(key, value);
}
<pre>
<code>


string 

string - js 

// string matching js
const text = "JavaScript is fun";
console.log(text.includes("Script")); // true
console.log(text.includes("script")); // false (case-sensitive)

// string matching python
string - pyton 
text = "Python is awesome"
print("Python" in text)     # ✅ True
print("python" in text)     # ❌ False (case-sensitive)


different naming conventions
naming conventions — 
ways to write multi-word names (like variables, functions, classes) in code

<table border="1" cellspacing="0" cellpadding="8">
  <thead>
    <tr>
      <th>Style</th>
      <th>Example</th>
      <th>Common Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>camelCase</td>
      <td><code>userName</code></td>
      <td>JS variables, functions, object keys</td>
    </tr>
    <tr>
      <td>PascalCase</td>
      <td><code>UserName</code></td>
      <td>Classes, React components</td>
    </tr>
    <tr>
      <td>snake_case</td>
      <td><code>user_name</code></td>
      <td>Python, databases, environment variables</td>
    </tr>
    <tr>
      <td>kebab-case</td>
      <td><code>user-name</code></td>
      <td>CSS class names, HTML attributes</td>
    </tr>
  </tbody>
</table>
